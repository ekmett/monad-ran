-- Finding the right Kan extension

module Control.Monad.Ran 
    ( 
      -- * The Yoneda Lemma
      Yoneda(..)
      -- * The codensity monad of a functor
    , Codensity(..)
      -- * A right Kan extension monad transformer
    , Ran(..)
      -- * Representing monads as right Kan extensions
    , RMonad
    , G
    , H
    , toRan
    , fromRan
    ) where

import Data.Monoid
import Data.Maybe (maybe)
import Control.Applicative
import Control.Monad
import Control.Monad.Identity
import Control.Monad.Cont
import Control.Monad.State
import Control.Monad.Error
import Control.Monad.Reader
import Control.Monad.Writer
import Control.Monad.RWS

-- | The Yoneda lemma

data Yoneda f a = Yoneda { getYoneda :: forall b. (a -> b) -> f b } 

instance Functor (Yoneda f) where
    fmap f m = Yoneda (\k -> getYoneda m (k . f))

instance Applicative f => Applicative (Yoneda f) where
    pure a = Yoneda (\f -> pure (f a))
    m <*> n = Yoneda (\f -> getYoneda m (f .) <*> getYoneda n id)

instance Monad f => Monad (Yoneda f) where
    return a = Yoneda (\f -> return (f a))
    m >>= k = Yoneda (\f -> getYoneda m id >>= \a -> getYoneda (k a) f)

instance MonadTrans Yoneda where
    lift m = Yoneda (\f -> liftM f m)

runYoneda :: Yoneda f a -> f a 
runYoneda (Yoneda f) = f id

-- | The Codensity monad of a functor/monad generated by a functor

data Codensity f a = Codensity { getCodensity :: forall b. (a -> f b) -> f b }

instance Functor (Codensity k) where
    fmap f m = Codensity (\k -> getCodensity m (k . f))

instance Applicative (Codensity f) where
    pure = return
    (<*>) = ap

instance Monad (Codensity f) where
    return x = Codensity (\k -> k x)
    Codensity m >>= k = Codensity (\c -> m (\a -> getCodensity (k a) c))

instance MonadTrans Codensity where
    lift m = Codensity (m >>=)

runCodensity :: Monad m => Codensity m a -> m a
runCodensity = flip getCodensity return

runCodensityApp :: Applicative f => Codensity f a -> f a
runCodensityApp = flip getCodensity pure

-- .. runCodensityPointed

-- | A right Kan extension transformer for a monad
data Ran m a = Ran { getRan :: forall b. (a -> G m b) -> H m b } 

instance RMonad m => Functor (Ran m) where
    fmap f m = Ran (\k -> getRan m (k . f))

class (Monad (Ran f), Monad f) => RMonad f where
    type G f    :: * -> *
    type H f    :: * -> *
    toRan      :: f a -> Ran f a
    fromRan    :: Ran f a -> f a

type Hom = (->)
type (:->) = ReaderT

data ErrorH b r  = ErrorH { getErrorH :: (b -> r) -> r } 
data ErrorTH b m r = ErrorTH { getErrorTH :: (b -> G m r) -> H m r }

-- Yoneda Identity ~ Codensity Identity
-- forall o. (a -> o) -> o
instance RMonad Identity where
    type G Identity = Identity
    type H Identity = Identity
    toRan m = Ran (m >>=)
    fromRan = flip getRan Identity

instance Monad (Ran Identity) where
    return a = Ran (\k -> k a)
    Ran m >>= k = Ran (\c -> m (\a -> getRan (k a) c))

-- Yoneda Endo a ~ forall o. (a -> o) -> o -> o ~ forall o. (a -> Identity o) -> Endo o
instance RMonad Maybe where
    type G Maybe = Identity
    type H Maybe = Endo
    toRan = maybe mempty return 
    fromRan f = appEndo (getRan f (Identity . return)) mempty

instance Monad (Ran Maybe) where
    return x = Ran (\k -> Endo (\_ -> runIdentity (k x)))
    Ran m >>= k = Ran (\c -> Endo (\z -> m (\a -> appEndo (getRan (k a) c) z)))
    fail = mempty

instance MonadPlus (Ran Maybe) where
    mzero = Ran (\_ -> Endo id)
    Ran m `mplus` n = Ran (\k -> Endo (\z -> appEndo (getRan m k) (appEndo (getRan n k) z)))

-- Yoneda (ErrorH e) ~ forall o. (a -> o) -> (e -> o) -> o
instance Error e => RMonad (Either e) where
    type G (Either b) = Identity
    type H (Either b) = ErrorH b
    toRan (Right x) = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
    toRan (Left x) = Ran (\_ -> ErrorH (\e -> e x))
    fromRan (Ran f) = getErrorH (f (Identity . Right)) Left

instance Error e => Monad (Ran (Either e)) where
    return x = Ran (\k -> ErrorH (\_ -> runIdentity (k x)))
    fail = throwError . strMsg
--  m >>= k = Ran (\c -> ErrorH (\e -> m (\a -> getErrorH (getRan (k a) c) e)))

instance Error e => MonadError (Ran (Either e)) where
    throwError x = Ran (\_ -> ErrorH (\e -> e x))
--  catchError f h = Ran (\k -> ErrorH (\e -> getErrorH (getRan f k) e))

instance Error e => MonadPlus (Ran (Either e)) where
    mzero = throwError noMsg
        
    


-- Yoneda (ErrorTH b m)
-- forall o. (a -> G m o) -> (b -> G m o) -> H m o
-- forall o. (a -> G m o) -> H m ((b -> G m o) -> o) ?
instance (RMonad m, Error b) => RMonad (ErrorT b m) where
    type G (ErrorT b m) = G m 
    type H (ErrorT b m) = ErrorTH b m

-- Yoneda f
-- Ran (Yoneda f) forall o. (a -> Identity o) -> f o 
instance Monad f => RMonad (Yoneda f) where
    type G (Yoneda f) = Identity
    type H (Yoneda f) = f
    toRan (Yoneda f) = Ran (\b -> f (runIdentity . b))
    fromRan (Ran f) = Yoneda (\b -> f (Identity . b))

-- Codensity f
-- forall o. (a -> f o) -> f o 
instance RMonad (Codensity f) where
    type G (Codensity f) = f
    type H (Codensity f) = f
    toRan (Codensity f) = Ran f
    fromRan (Ran f) = Codensity f

-- Yoneda (Reader r)
-- forall o. (a -> o) -> r -> o
instance RMonad (Reader e) where
    type G (Reader e) = Identity
    type H (Reader e) = Reader e
    toRan m = Ran (\f -> liftM (runIdentity . f) m)
    fromRan (Ran f) = f Identity

-- embedded as CPS'd State to avoid superfluous 'mappend mempty' calls
-- specialized Codensity (Reader w)
-- forall o. (a -> w -> o) -> w -> o
instance Monoid w => RMonad (Writer w) where
    type G (Writer w) = Hom w
    type H (Writer w) = Hom w
    toRan (Writer (a,w'))  = Ran (\f w -> f a (w `mappend` w'))
    fromRan (Ran f) = Writer (f (,) mempty)
    -- forall o. (a -> w -> o) -> o
    -- type H (Writer w) = Identity

-- Codensity (Reader s)
-- forall o. (a -> s -> o) -> s -> o
instance RMonad (State s) where
    type G (State s) = Hom s
    type H (State s) = Hom s
    toRan (State g)  = Ran (\f -> uncurry f . g)
    fromRan (Ran f)  = State (f (,))

-- Codensity (Const r)
-- (a -> r) -> r
instance RMonad (Cont r) where
    type G (Cont r) = Const r
    type H (Cont r) = Const r

-- forall o. (a -> G m o) -> r -> H m o 
instance RMonad m => RMonad (ReaderT e m) where
    type G (ReaderT e m) = G m
    type H (ReaderT e m) = e :-> H m

-- forall o. (a -> w -> G m o) -> H m o
-- forall o. (a -> G m (w -> o)) -> H m (w -> o) ?
instance (Monoid w, RMonad m) => RMonad (WriterT w m) where
    type G (WriterT w m) = w :-> G m
    type H (WriterT w m) = H m

-- forall o. (a -> s -> G m o) -> s -> H m o 
-- forall o. (a -> G m (s -> o)) -> H m (s -> o) ?
instance RMonad m => RMonad (StateT s m) where
    type G (StateT s m) = s :-> G m
    type H (StateT s m) = s :-> H m

-- (a -> G m r) -> H m r
data ConstT r f a = ConstT { getConstT :: f r } 
instance RMonad m => RMonad (ContT r m) where
    type G (ContT r m) = ConstT r (G m)
    type H (ContT r m) = ConstT r (H m)
